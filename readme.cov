B################################################
# From Edgar: FASTA file
################################################
cat covid-3-12.fasta | sed  -E 's/>.+(EPI_ISL_[0-9]+)/>\1/' > cov.fas (to avoid this step: don't export isolate id)
cat gisaid_covid19_3_19.tsv | grep [Hh]uman | cut -f2 > epi-human 2> error 
bioseq -p"file:epi-human" cov.fas > cov-human.fas
#check host info:
cut -f7 gisaid-3-24.tsv | sort | uniq -c

# CSV file
# better to be TSV (comma problem when using cut)
# cut -f2,7 -d',' gisaid_covid19_3_12.csv | grep -v host | tr ',' '\t' > host-info.tsv
# grep Human host-info.tsv | cut -f1 > ids-human
# grep Environment host-info.tsv | cut -f1 > ids-environ
# grep Rhinolophus host-info.tsv | cut -f1 > ids-outgroup
# grep -v "Human\|Rhinolophus\|Environ" host-info.tsv | cut -f1 > ids-animal
# bioseq -p"file:ids-human" cov.fas > cov-human.fas
# bioseq -p"file:ids-outgroup" cov.fas > cov-outgroup.fas

#######################################
# Parse GISAID sequences fasta
######################################

1. bioseq -B cov.fas # burst into individual files
1a. move the un-bursted file out the "human-files" directory!!!
mv cov-human.fas ../

2. sam align (weigang@wallace:~/cov-03-09-2030/host-human$ for f in *.fas; do ../sam-align.bash $f; done )
    nucmer --sam-long=COH1 B111.fa COH1.fa
    samtools view -b COH1.sam -T B111.fa > COH1.bam
    samtools sort COH1.bam -o COH1.sorted.bam
    samtools index COH1.sorted.bam

    with script: for f in *.fas; do ../sam-align.bash $f; done

3c. Less strict call: bcftools mpileup -Ou -f ../ref.fas   *.sorted.bam | bcftools call -mv --ploidy-file ploidy.txt  -Ob -o calls.bcf -P 0.05 (or -P 0.1; large P value for less strict call, default 1.1e-3)
# 3b. bcftools mpileup -Ou -f ../ref.fas  *.sorted.bam | bcftools call -mv --ploidy-file ploidy.txt  -Ob -o calls.bcf, with default ploidy as 1:
weigang@wallace:~/cov-03-09-2020/cov57$ cat ploidy.txt
*       *       *       M       1
###############################
# 3d. outgroup mapping:
################################
bcftools mpileup -Ou -f ../ref.fas  otg.sorted.bam | bcftools call -mv --ploidy-file ../ploidy.txt  -Ob -o otg.bcf -P 0.1

# Not used: 3a.  samtools mpileup -uf ../ref.fas *.sorted.bam > cov.mpileup &

## bcftools call -c -v --ploidy 1 cov.mpileup > raw.vcf

5. bcftools stats raw.vcf > vcf.stats # check TsTv ratio

6a. bcftools view -m2 -M2 --types snps calls.bcf > snps.bcf ( get only biallelic SNPs)
6b. vcftools --vcf input_file.vcf --remove-indels --recode --recode-INFO-all --out cov.vcf # filter SNPs only
6c. fitler outgroup SNPs:
bcftools view otg.bcf > otg.vcf
weigang@wallace:~/cov-03-12-2020$ bgzip snps2.vcf
weigang@wallace:~/cov-03-12-2020$ tabix snps2.vcf.gz
weigang@wallace:~/cov-03-12-2020$ bgzip otg.vcf
weigang@wallace:~/cov-03-12-2020$ tabix otg.vcf.gz

bcftools isec -n=2 -w1 otg.vcf.gz snps2.vcf.gz > otg-isec-sites.vcf
bgzip & tabix to index
vcf-merge -d -R 0 otg-isec-sites.vcf.gz snps2.vcf.gz > snps-ref.vcf ( no duplicated line; add ref state "0" instead of missing)

7. filter sites by allele counts: only informative sites
bcftools view snps.bcf > snps.vcf
vcftools --vcf snps.vcf --mac 2 --recode --recode-INFO-all --out snps2.vcf

7. Get sample FASTA:
bcftools query -l snps.bcf > samples
cat samples | while read line; do echo ">$line"; bcftools query -s "$line" -f '[%TGT]' snps-ref.vcf; echo; done > samples.fas

(8 get ref FASTA; if necessary
echo ">ref" >> sample.fas
grep "^CP" gbs50-snps2.vcf | cut -f4 | paste -s -d '' >> sample.fas)

9. SNP counts (for verification)
bcftools view snps.bcf > snps-ref.vcf
vcftools --vcf --counts snps-ref.vcf

#10. Remove gapped samples
#bioseq -d'ambig:20' samples.fas > samples2.fas # remove seqs with 20 or more missing/non-ATCG bases "."
cat samples2.fas | sed "s/.sorted.bam//" > samples3.fas # fix names
#bioaln -i'fasta' --gap-char 'n' samples3.fas  > samples4.aln # change gaps to "n" to help reducing unique haps


#9. Annotate with gff


#####################
# MST by Perl
##################
# 1. replace gap char
# bioaln -i'fasta' --gap-char 'n' cov-275-outgroup.fas  > sample4.aln

# 2. run sssp_from_haps.pl
# perl hapnet.pl --vcf snps-ref.vcf --genome ref.gb --hap samples4.aln --output json 2> tmp.log > net.json

# 1. Impute: run "impute-hap.pl" twice
perl impute-hap.pl --dump-missing samples.aln > missing | sort -n | uniq -c
=> get start\end

# (a) removed seqs > 10% "." (non-ATCG); 
# (b) impute positions by the closest all-ATCG seq; 
# (c) output uniq STs ("imputed.aln" & "impute.log")
perl impute-hap.pl --start 5 --end 156 samples.aln > log

# 2. Get MST
hapnet.pl --genome ref.gb --vcf snps2-ref-03-19.vcf --hap imputed.aln --impute-log impute.log
# (a) net.json
# (b) edges.tsv
# (c) nodes.tsv

############################
# Bootstrap analysis (not working yet)
#############################

1. Level 1: multiple runs (of the same haplotype alignmement)

Brian: really high support


2. Level 2: unique-fied STs => bootstrap => multiple runs

2a. for original
bioaln -u ../samples4.aln > boot-0.aln
../hapnet.pl --genome ../ref.gb --vcf ../snps-ref.vcf --hap boot-0.aln --output edge --no-uniq-seq  > net-0.tsv
cut -f1,2 net-0.tsv | sort -u | tr '\t' '-' > edge-0

2b. for bootstrapped (test)
bioaln --boot boot-0.aln > boot-1.aln
perl ../hapnet.pl --genome ../ref.gb --vcf ../snps-ref.vcf --hap boot-1.aln --output edge --no-uniq-seq  > net-1.tsv
cut -f1,2 net-1.tsv | sort -u | tr '\t' '-'> edge-1
comm -12 edge-0 edge-1 # get common edges

2c. bootstrap (loop)
for i in {1..99}; do bioaln --boot boot-0.aln > boot-$i.aln; done &
for i in {1..99}; do perl ../hapnet.pl --genome ../ref.gb --vcf ../snps-ref.vcf --hap boot-$i.aln --output edge --no-uniq-seq  > net-$i.tsv; done &
for i in {1..99}; do cut -f1,2 net-$i.tsv | sort -u | tr '\t' '-' > edge-$i; done
cat edge-0 | while read line; do echo -ne "$line\t"; grep $line edge-* | wc -l ; done # boot support for each edge

3. Level 3: bootstrapped haplotype alignment (hard to do, since STs are not comparable between runs)

4. Majority-rule parent (MRP) network from bootstrapped ST networks
4a. Collect all non-root STs;
4b. Trace back to ST1, each step taking the majority ST as the parent
    foreach v:
    	    p = get_parent;
	    if (p has NOT been visited) {
	       label p as visited;
	       create a new edge (from = p, to = v)
	    } 	       
4c. Reconstruct network
4d. Attaching nodelist + edgelist

4e. Get majority parents for each non-root node:
cat edge-* | sort | uniq -c | sort -rn > unique-edges # counts of uniq edges in 99 bootstrapped samples + 1 un-bootstrapped 

#############
# site imputation
#######################
"sample.aln", N=832 seqs, L=132 SNPs
Number of non-ATCG's per site:
> table(x)
  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  18  19  20  21 
526 489 437 413 219  32  32  29  30  30  10  11   1   1   1   2   2   3   4   3 
 22  24  25  26  27  28  29  30  31  33  34  35  36  37  38  39  40  41  42  43 
  2   1   4   1  25   1   3   1   3   2  10   6   1   5   5  10   2   4   5   6 
 44  45  46  48  50  51  52  53  54  56  58  64  65  67  68  69  70  74  75  76 
  5   5   4   3  14   2   1   1   3  18   1   7   1   3   2   2  10   4  16  12 
 77  78  79  81  84  85  86  87  88  89  90  91  92  93  95  96  97  98  99 101 
  1   7   4  61   4   4   5   1   1   2   2   1   1   2   2   1   4   2   1   1 
102 103 104 105 106 108 110 111 112 118 119 120 121 122 123 124 125 126 127 128 
 19  20   1   5   5   2   2   1   1   3   2   2  11  10  11  11  32 472 491 506 
129 130 131 132 
523 528 536 532 

After removing seqs with 10% or more non-ATCG's:
"sample-03-19.aln", N=712 seqs, L=132 SNPs
> table(x)
x
  1   2   3   4   5   6   7   8   9  10  11  12  20  21  22  24  25  27  39  42 
416 379 331 309 126   9   9   9  11  11   4   6   1   2   1   1   2   2   4   1 
 48  50  54  68  69  70  74  75  78  79  81  86  91  93  95  97  98  99 101 105 
  1  10   2   1   1   3   2   2   5   2   1   2   1   1   1   1   1   1   1   4 
106 108 110 111 112 118 119 122 123 124 125 126 127 128 129 130 131 132 
  4   1   2   1   1   1   1   1   1   1   4 370 385 398 415 421 427 424 

perl impute-hap.pl --dump-missing samples.aln > missing | sort -n | uniq -c
=> remove end 12 sites 1-5 & 126-132; then impute the seq with the nearest non-ATCG nabe:

perl impute-hap.pl sample-03-19.aln > sample-03-19-impute.aln 2> sample-03-19-impute.log &

# 1. Position-specific imputation:
perl impute-hap.pl test-impute.aln 2> log
./hapnet.pl --genome ref.gb --vcf snps2-ref-03-19.vcf --hap imputed.aln --impute-log impute.log 
=> output 3 files: net.json; nodes.tsv; edges.tsv)

# 2. bootstrap
boot-net.bash 99

# 3. reconstruct majority-parent network (doesn't work: cycles in majority parents, leading to unconnected graph)
# hapnet.pl --genome ref.gb --vcf snps2-ref-03-19.vcf --hap imputed.aln --output json --impute-log impute.log --majority-parent pa-cts.long > mpn.json

# 3. reconstruct MST using boot edges
hapnet.pl --genome ref.gb --vcf snps2-ref-03-19.vcf --hap imputed.aln --output json --impute-log impute.log --boot-edges pa-cts.tsv

